#!/usr/bin/env python
#XXX ^ must change to fit environment
import numpy
from math import hypot
from heapq import *
import threading # might not be necessary if thread not started here
import util # needed for state object

def set_target((x,y)):
	'''sets the target to x, y
	returns immediately'''
	newtarget = (x,y)
	pass

newtarget = None

start = (0,0) # XXX Must get from state
finish = (10,10) # XXX Must get from state

# XXX all of these should probably be stored in state
openset = [(cost(start, finish), start)]
closedset = set([])
camefrom = {}
g_score = {start:0} # best known cost from start
f_score = {start:cost(start,finish)} # estimated total cost to target

# probably too ugly of a hack to work
def nullGenerator():
	raise StopIteration

def resetAstar(new_start, new_finish):
	"""
	Reset the A* search space to do a search from given start position 
	to given end position, return the generator object
	"""
	if new_finish is None or new_start is None:
		return nullGenerator # stops iterating immediately
    start, finish = new_start, new_finish
    openset = heapify([(cost(start, finish), start)])
    closedset = set([])
    camefrom = {}
    g_score = {start:0} # best known cost from start
    f_score = {start:cost(start,finish)} # estimated total cost to target
    return astar() # returns generator


def pathfinderThread():
	"""The thread that continually waits on target change and 
	runs A* whenever a new target is set"""
	iterastar = nullGenerator
	while True:
		# stuff happens
		if newtarget != finish:
			start = (0,0) # XXX GET CURRENT POSITION FROM STATE
			iterastar = resetAstar(start,newtarget)
			newtarget = None
		if newtarget != None:
			try:
				iterastar()
			except StopIteration:
				# XXX astar finished, so we need to either 
				# alert something or update state (the latter probably)
				
				pass
		continue

def cost((x1,y1),(x2,y2)): 
	"""
	Returns the equivalent distance between two given points.
	Currently assumes equivalent distance is Euclidean norm.

	XXX Here is where the obstacle sensor comes in
	"""
#   return abs(x1-x2) + abs(y1-y2)
    return hypot(x1-x2,y1-y2)

def neighbors(x,y=None):
	"""
	Generates all neighbors of input location.
	We use a genexpr to produce neighbors because there may be important 
	edge cases best handled before the neighbors are even created

	XXX another place the sensors can come in
	"""
	if isinstance(x,tuple): x,y = x[0], x[1]
    yield (x+1, y)
    yield (x-1, y)
    yield (x, y+1)
    yield (x, y-1)


# will have to yield some value in between iterations 
# (to pause and allow other calculations)
# but what value would be useful?

# this A* is completely transparent in its workings so it can be 
# interrupted with incomplete path if need be

def astar():
    """
	computes A* over an arbitrary graph generated by neighbors() 
	and weighted by cost()
	"""
	done = 0
    while openset and not done:
        current = heappop(openset)
        yield current # produces current best target, and distance to final target
        if current[1] == finish:
            #DONE DONE DONE
            done = True
            continue
            #break
        closedset.add(current[1])
        for i in neighbors(current[1]):
            tentative_g = g_score[current[1]] + cost(current[1],i)
            tentative_f = tentative_g + cost(i,finish)
            if i in closedset and tentative_f >= f_score[i]:
                continue
            if i not in openset or tentative_f < f_score[i]:
                camefrom[i] = current[1]
                g_score[i] = tentative_g
                f_score[i] = tentative_f
                if i not in openset:
                    heappush(openset, (tentative_f,i))
    
    
    pass #FAIL

def trace_path(src, dest):
	"""
	
	"""
    path = [dest]
    cur = camefrom[dest]
    while cur != src:
        #print cur
        path.append(cur)
        cur = camefrom[cur]
    return reversed(path)

def findloops(graph):
    for i in graph.keys():
        j = graph[i]
        l = []
        while j in graph.keys():
            if j in l:
                print "AHAHA " + str(l)
                break
            l.append(j)
            j = graph[j]


pathfinder = astar()
for i in pathfinder:
#   print i
    pass
print "##"
for i in trace_path(start, finish):
    print i
print "###"
#print camefrom[(4,3)]
#print camefrom[(4,4)]
#print camefrom[(0,0)]
print "####"
findloops(camefrom)


